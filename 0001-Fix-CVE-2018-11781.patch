From 7dc7e21bfd623b4c31cd16076ae1dd902ecb964d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ond=C5=99ej=20Lyson=C4=9Bk?= <olysonek@redhat.com>
Date: Wed, 26 Sep 2018 17:34:43 +0200
Subject: [PATCH] Fix CVE-2018-11781

Based on upstream revision
https://svn.apache.org/viewvc?view=revision&revision=1826179

I left out some bits from the patch that seemed unnecessary
and that could potentially break something.

Resolves: rhbz#1632998
---
 lib/Mail/SpamAssassin/Conf/Parser.pm | 22 ++++++++++++++++------
 1 file changed, 16 insertions(+), 6 deletions(-)

diff --git a/lib/Mail/SpamAssassin/Conf/Parser.pm b/lib/Mail/SpamAssassin/Conf/Parser.pm
index b42a390..d3fa686 100644
--- a/lib/Mail/SpamAssassin/Conf/Parser.pm
+++ b/lib/Mail/SpamAssassin/Conf/Parser.pm
@@ -1175,7 +1175,7 @@ sub add_test {
   my $conf = $self->{conf};
 
   # Don't allow invalid names ...
-  if ($name !~ /^\D\w*$/) {
+  if ($name !~ /^[_[:alpha:]]\w*$/) {
     $self->lint_warn("config: error: rule '$name' has invalid characters ".
 	   "(not Alphanumeric + Underscore + starting with a non-digit)\n", $name);
     return;
@@ -1282,8 +1282,14 @@ sub add_regression_test {
 sub is_meta_valid {
   my ($self, $name, $rule) = @_;
 
+  # $meta is a degenerate translation of the rule, replacing all variables (i.e. rule names) with 0. 
   my $meta = '';
   $rule = untaint_var($rule);  # must be careful below
+  # Bug #7557 code injection
+  if ( $rule =~ /\S(::|->)\S/ )  {
+    warn("is_meta_valid: Bogus rule $name: $rule") ;
+    return 0;
+  }
 
   # Lex the rule into tokens using a rather simple RE method ...
   my $lexer = ARITH_EXPRESSION_LEXER;
@@ -1295,16 +1301,20 @@ sub is_meta_valid {
   }
   # Go through each token in the meta rule
   foreach my $token (@tokens) {
-    # Numbers can't be rule names
-    if ($token !~ /^[A-Za-z_][A-Za-z0-9_]*\z/s) {
+    # If the token is a syntactically legal rule name, make it zero
+    if ($token =~ /^[_[:alpha:]]\w+\z/s) {
+      $meta .= "0 ";
+    }
+    # if it is a number or a string of 1 or 2 punctuation characters (i.e. operators) tack it onto the degenerate rule
+    elsif ( $token =~ /^(\d+|[[:punct:]]{1,2})\z/s ) {
       $meta .= "$token ";
     }
-    # Zero will probably cause more errors
+    # WTF is it? Just warn, for now. Bug #7557
     else {
-      $meta .= "0 ";
+      $self->lint_warn("config: Strange rule token: $token", $name);
+      $meta .= "$token ";
     }
   }
-
   my $evalstr = 'my $x = ' . $meta . '; 1;';
   if (eval $evalstr) {
     return 1;
-- 
2.17.1

